<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dyna-cores on Dyna FRP</title><link>https://anton-k.github.io/dyna-frp/dyna-core/</link><description>Recent content in Dyna-cores on Dyna FRP</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://anton-k.github.io/dyna-frp/dyna-core/index.xml" rel="self" type="application/rss+xml"/><item><title>Conclusion</title><link>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/09-conclusion/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/09-conclusion/</guid><description>We have studied the FRP library dyna. It features minimal and elegant approach to FRP implementation that is easy to grasp and use. I hope that it will be useful for you to create nice interactive applications.
What&amp;rsquo;s next? There are several ready to be used bindings for dyna.
You can
create games and animations with dyna-gloss.
create terminal user interfaces (TUI) with dyna-brick
more to come in the future</description></item><item><title>Core FRP library Tutorial</title><link>https://anton-k.github.io/dyna-frp/dyna-core/tutorial-toc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anton-k.github.io/dyna-frp/dyna-core/tutorial-toc/</guid><description>The dyna is functional reactive programming (FRP) library for Haskell. It implements classical FRP and provides easy to use interface to write call-back heavy interactive applications. It takes an imperative definition for event streams as a basis and granted with Haskell power for abstractions builds elegant DSL on top of it.
Tutorial Introduction Event streams Game example Dynamic values Main FRP monad Control flow. Recursion and sharing How to make bindings Parser for event streams Conclusion Quick Reference Resources Resources Hackage docs - docs for dyna library Conal Elliott FRP publications - great papers from one of the inventors of FRP concept Ivan Perez FRP publications - great papers explainig the FRP concept and arrow style FRP Haskell FRP zoo - lists lots of examples in various FRP libraries</description></item><item><title>Dynamics - continuous processes</title><link>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/04-dynamics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/04-dynamics/</guid><description>We have dedicated a significant amount of time to event streams as they are the corner stone of our FRP library. Often in FRP we find another key element called Behavior. It&amp;rsquo;s often conceptually represented as a function from time to value:
type Behavoir a = Time -&amp;gt; a This God like vision of the whole function would be hard to implement in practice. And in Classical FRP approach Behaviors are often represented with event streams as so called stepper functions:</description></item><item><title>Event streams</title><link>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/02-event-streams/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/02-event-streams/</guid><description>The core type of the library is event stream Evt. The main idea of the library is to use very simple imperative representation of the event streams and use convenient combinators to build compound event streams out of simple ones.
Often in FRP research papers event stream conceptually is represented as list of some events that happen at certain time stamps:
type Events event = [(Time, event)] The list is infinite and we can receive events as they come.</description></item><item><title>Functions to control the flow of application</title><link>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/06-control-flow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/06-control-flow/</guid><description>In this section we discuss some peculiarities of the library. How to make recursive definitions with event streams and how to share effectful event streams and dynamic values.
Grain of salt. Sharing event streams If all it was so cool and dandy. But there is grain of salt to it It is better to be aware of. All event streams perform dirty operations under the hood. So in some sense they are like IO () and this means that we can not share the values by means valid for pure values.</description></item><item><title>Generic FRP monad</title><link>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/05-backbone-monad/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/05-backbone-monad/</guid><description>Can you recall how we said that event streams and dynamics are general in terms of the backbone monad but we assume it to be IO. Now time has come to find what monad can we use here. By default in the interpreter session it will be specialized to IO. But it&amp;rsquo;s useful to know that it can be more generic.
It turns out that to be able to use a monad in place of IO we need to have following properties:</description></item><item><title>Get started</title><link>https://anton-k.github.io/dyna-frp/dyna-core/get-started/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anton-k.github.io/dyna-frp/dyna-core/get-started/</guid><description>The dyna is functional reactive programming (FRP) library for Haskell. It implements classical FRP and provides easy to use interface to write call-back heavy interactive applications. It takes an imperative definition for event streams as a basis and granted with Haskell power for abstractions builds elegant DSL on top of it.
Installation The library can be installed with cabal from hackage
&amp;gt; cabal install dyna --lib Also it can be used with stack.</description></item><item><title>Interactive Game for Rock-Paper-Scissors</title><link>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/03-event-game-example/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/03-event-game-example/</guid><description>For now we know what is event stream and how to use it. Let&amp;rsquo;s define a simple game with them. FRP is often associated with UI applications or Graphical games or even Creation of dynamic web pages.
But I&amp;rsquo;d like to provide a solid understanding of the basic concepts for you with simple example that can be run right in the REPL. For that we can use Rock-Paper-Scissors game and build an application for it as a Haskell function.</description></item><item><title>Introduction</title><link>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/01-intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/01-intro/</guid><description>FRP allows us to implement interactive applications with nice and declarative style. We can push IO-interaction to the boundaries of the application. And for some applications it even seems that all functions are pure and no dirty operations happen.
There are many implementations of the FRP in Haskell. Why do we need yet another one? The main focus of the dyna library is simplicity of implementation. Once you grasp the core data types and concepts it is easy to derive the implementation.</description></item><item><title>Parsers for event streams</title><link>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/08-parser/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/08-parser/</guid><description>This is an experimental feature. The parser is an interesting way to accumulate events from the stream. Imagine that event stream carries a tokens for some parser. And we can parse a single value from several successive values. We expect that our value is compound and we gradually take it bit by bit from the event stream.
In Haskell there are nice parser combinators libraries which create very flexible parsers with instance to Applicative.</description></item><item><title>Quick reference to the core FRP functions</title><link>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/101-reference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/101-reference/</guid><description>There are two core data types:
Evt m a - for event streams Dyn m a - for dynamic processes The Evt is a callback processor. Giving some callback procedure it can run it each time some event happens.
The Dyn is an observation of an event. It&amp;rsquo;s stepwise constant continuous signal of values that starts with some initial value. It produces that value until the next value happen on the event stream then it produces that value until the next value will come.</description></item><item><title>Resources and publications</title><link>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/102-resources/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/102-resources/</guid><description>Library on Hackage:
TODO Publications:
TODO Talks and videos:
TODO Tutorials and guides:
TODO</description></item><item><title>Using dyna to create bindings to imperative libraries</title><link>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/07-make-bindings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/07-make-bindings/</guid><description>Here we will see how we can use the library to create FRP-based bindings to various imperative libraries. We will study the common patterns that reappear during the implementation.
For now we have bindings to the libraries brick (TUIs) and gloss (Graphics, gaming). But if you need to use it with your own favorite library and make it shine with FRP you can find this chapter useful.
How to make our own instances for Frp Why do we need our own instances for Frp class?</description></item></channel></rss>