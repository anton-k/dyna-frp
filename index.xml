<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dyna FRP</title><link>https://anton-k.github.io/dyna-frp/</link><description>Recent content on Dyna FRP</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://anton-k.github.io/dyna-frp/index.xml" rel="self" type="application/rss+xml"/><item><title>Callback heaven for FRP</title><link>https://anton-k.github.io/dyna-frp/paper/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anton-k.github.io/dyna-frp/paper/</guid><description>Abstract The Functional reactive programming provides a declarative solution to the task of creation of interactive applications. Often it is contrasted to the imperative approach that relies on callback handlers, event loops and mutation of the state which is quickly can become hard to understand and maintain. In this work we show how with imperative definition we can build DSL that covers all combinators of the FRP approach. We will go to the center of imperative hurricane to build declarative interface that is easy to understand, use and extend.</description></item><item><title>Conclusion</title><link>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/09-conclusion/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/09-conclusion/</guid><description>We have studied the FRP library dyna. It features minimal and elegant approach to FRP implementation that is easy to grasp and use. I hope that it will be useful for you to create nice interactive applications.
What&amp;rsquo;s next? There are several ready to be used bindings for dyna.
You can
create games and animations with dyna-gloss.
create terminal user interfaces (TUI) with dyna-brick
more to come in the future</description></item><item><title>Core FRP library Tutorial</title><link>https://anton-k.github.io/dyna-frp/dyna-core/tutorial-toc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anton-k.github.io/dyna-frp/dyna-core/tutorial-toc/</guid><description>The dyna is functional reactive programming (FRP) library for Haskell. It implements classical FRP and provides easy to use interface to write call-back heavy interactive applications. It takes an imperative definition for event streams as a basis and granted with Haskell power for abstractions builds elegant DSL on top of it.
Tutorial Introduction Event streams Game example Dynamic values Main FRP monad Control flow. Recursion and sharing How to make bindings Parser for event streams Conclusion Quick Reference Resources Resources Hackage docs - docs for dyna library Conal Elliott FRP publications - great papers from one of the inventors of FRP concept Ivan Perez FRP publications - great papers explainig the FRP concept and arrow style FRP Haskell FRP zoo - lists lots of examples in various FRP libraries</description></item><item><title>dyna-brick tutorial</title><link>https://anton-k.github.io/dyna-frp/dyna-brick/tutorial-toc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anton-k.github.io/dyna-frp/dyna-brick/tutorial-toc/</guid><description>The dyna-brick is a FRP for brick library. The brick is a great library for building terminal user applications (TUIs). With brick we can write terminal user interfaces (TUIs) painlessly! And with FRP approach it becomes even more declarative.
Tutorial Introduction Example: Puzzle 15 Quick reference Resources Official brick tutorial Samuel Tay brick tutorial Hackage docs</description></item><item><title>dyna-gloss tutorial</title><link>https://anton-k.github.io/dyna-frp/dyna-gloss/tutorial-toc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anton-k.github.io/dyna-frp/dyna-gloss/tutorial-toc/</guid><description>FRP bindings for library gloss which is great to create 2D animation and graphics. It features declarative and functional approach to drawing the pictures and we make it even more declarative with FRP style.
Gloss hides the pain of drawing simple vector graphics behind a nice data type and a few display functions. Gloss uses OpenGL under the hood, but you won&amp;rsquo;t need to worry about any of that. Get something cool on the screen in under 10 minutes.</description></item><item><title>dyna-gloss tutorial</title><link>https://anton-k.github.io/dyna-frp/dyna-processing/tutorial-toc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anton-k.github.io/dyna-frp/dyna-processing/tutorial-toc/</guid><description>FRP bindings for library processing-for-haskell which is great to create 2D and 3D animation and graphics.
The library implements the Processing language. It&amp;rsquo;s an imperative EDSL for graphics and animation. It&amp;rsquo;s very easy and fun to use. There are many books on processing and community is fairly active. We can find the quick start guide and lots of examples in the project repository on github https://github.com/anton-k/processing-for-haskell (see the directory examples). There is a tutorial at the project homepage at github: https://github.</description></item><item><title>Dynamics - continuous processes</title><link>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/04-dynamics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/04-dynamics/</guid><description>We have dedicated a significant amount of time to event streams as they are the corner stone of our FRP library. Often in FRP we find another key element called Behavior. It&amp;rsquo;s often conceptually represented as a function from time to value:
type Behavoir a = Time -&amp;gt; a This God like vision of the whole function would be hard to implement in practice. And in Classical FRP approach Behaviors are often represented with event streams as so called stepper functions:</description></item><item><title>Event streams</title><link>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/02-event-streams/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/02-event-streams/</guid><description>The core type of the library is event stream Evt. The main idea of the library is to use very simple imperative representation of the event streams and use convenient combinators to build compound event streams out of simple ones.
Often in FRP research papers event stream conceptually is represented as list of some events that happen at certain time stamps:
type Events event = [(Time, event)] The list is infinite and we can receive events as they come.</description></item><item><title>FRP for building terminal user applications (TUIs)</title><link>https://anton-k.github.io/dyna-frp/dyna-brick/tutorial/00-intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anton-k.github.io/dyna-frp/dyna-brick/tutorial/00-intro/</guid><description>In this tutorial we will study the FRP binding to the brick library. The brick is suitable for creation of TUIs. Interactive command line tools. It features declarative description of the terminal widgets. The application is run with state-machine like approach. We have a function that renders the state of application on the screen and we have a function that updates the state on events.
Brick is a wonderful library! We can make it even better if we use FRP with it.</description></item><item><title>FRP for gloss gaming/animation library</title><link>https://anton-k.github.io/dyna-frp/dyna-gloss/tutorial/00-intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anton-k.github.io/dyna-frp/dyna-gloss/tutorial/00-intro/</guid><description>In this tutorial we will study the FRP binding to the gloss library. The gloss is suitable to create animations and games. It features declarative description of drawings. The application is run with state-machine like approach. We have a function that renders the state of application on the screen and we have a function that updates the state on events.
With FRP we use the same functions for drawing as they are defined in the gloss (see the module Graphics.</description></item><item><title>FRP for processing gaming/animation library</title><link>https://anton-k.github.io/dyna-frp/dyna-processing/tutorial/00-intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anton-k.github.io/dyna-frp/dyna-processing/tutorial/00-intro/</guid><description>In this tutorial we will study the FRP binding to the processing-for-haskell library. The processing-for-haskell is suitable to create animations and games. It embeds Processing language into Haskell. The application is run with state-machine like approach. We have a function that renders the state of application on the screen and we have a function that updates the state on events.
With FRP we use the same functions for drawing as they are defined in the gloss (see the module Graphics.</description></item><item><title>FRP Gloss example</title><link>https://anton-k.github.io/dyna-frp/dyna-gloss/tutorial/01-example/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anton-k.github.io/dyna-frp/dyna-gloss/tutorial/01-example/</guid><description>Let&amp;rsquo;s study another example. In this application we are going to paint green and red circles on the screen. We paint in the mouse position when we press Right Button and we can change the color when we press the Left Button.
The complete code can be found in the directory: dyna-gloss/examples/Ball.hs.
Initialise application Let&amp;rsquo;s start with an empty screen and setup all the defaults:
module Main where import Dyna.Gloss -- | Screen specification spec :: Spec spec = defSpec { spec&amp;#39;display = InWindow &amp;#34;Main&amp;#34; (700, 700) (50, 50) } -- | Main app main = runApp spec $ pure pic pic = mempty This should draw an empty screen.</description></item><item><title>FRP processing example</title><link>https://anton-k.github.io/dyna-frp/dyna-processing/tutorial/01-example/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anton-k.github.io/dyna-frp/dyna-processing/tutorial/01-example/</guid><description>Let&amp;rsquo;s study another example. In this application we are going to paint green and red circles on the screen. We paint in the mouse position when we press Right Button and we can change the color when we press the Left Button.
The complete code can be found in the directory: dyna-processing/examples/Ball.hs.
Init application Let&amp;rsquo;s start with an empty screen and setup all the defaults:
module Main where import Dyna.Proc -- | Screen specification spec :: Spec spec = Spec $ size (P2 700 700) -- | Main app main = runApp spec $ pure (initDraw &amp;lt;&amp;gt; pic) where initDraw = background white pic = mempty This should draw an empty screen.</description></item><item><title>Functions to control the flow of application</title><link>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/06-control-flow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/06-control-flow/</guid><description>In this section we discuss some peculiarities of the library. How to make recursive definitions with event streams and how to share effectful event streams and dynamic values.
Grain of salt. Sharing event streams If all it was so cool and dandy. But there is grain of salt to it It is better to be aware of. All event streams perform dirty operations under the hood. So in some sense they are like IO () and this means that we can not share the values by means valid for pure values.</description></item><item><title>Generic FRP monad</title><link>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/05-backbone-monad/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/05-backbone-monad/</guid><description>Can you recall how we said that event streams and dynamics are general in terms of the backbone monad but we assume it to be IO. Now time has come to find what monad can we use here. By default in the interpreter session it will be specialized to IO. But it&amp;rsquo;s useful to know that it can be more generic.
It turns out that to be able to use a monad in place of IO we need to have following properties:</description></item><item><title>Get started</title><link>https://anton-k.github.io/dyna-frp/dyna-core/get-started/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anton-k.github.io/dyna-frp/dyna-core/get-started/</guid><description>The dyna is functional reactive programming (FRP) library for Haskell. It implements classical FRP and provides easy to use interface to write call-back heavy interactive applications. It takes an imperative definition for event streams as a basis and granted with Haskell power for abstractions builds elegant DSL on top of it.
Installation The library can be installed with cabal from hackage
&amp;gt; cabal install dyna --lib Also it can be used with stack.</description></item><item><title>Interactive Game for Rock-Paper-Scissors</title><link>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/03-event-game-example/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/03-event-game-example/</guid><description>For now we know what is event stream and how to use it. Let&amp;rsquo;s define a simple game with them. FRP is often associated with UI applications or Graphical games or even Creation of dynamic web pages.
But I&amp;rsquo;d like to provide a solid understanding of the basic concepts for you with simple example that can be run right in the REPL. For that we can use Rock-Paper-Scissors game and build an application for it as a Haskell function.</description></item><item><title>Introduction</title><link>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/01-intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/01-intro/</guid><description>FRP allows us to implement interactive applications with nice and declarative style. We can push IO-interaction to the boundaries of the application. And for some applications it even seems that all functions are pure and no dirty operations happen.
There are many implementations of the FRP in Haskell. Why do we need yet another one? The main focus of the dyna library is simplicity of implementation. Once you grasp the core data types and concepts it is easy to derive the implementation.</description></item><item><title>Parsers for event streams</title><link>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/08-parser/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/08-parser/</guid><description>This is an experimental feature. The parser is an interesting way to accumulate events from the stream. Imagine that event stream carries a tokens for some parser. And we can parse a single value from several successive values. We expect that our value is compound and we gradually take it bit by bit from the event stream.
In Haskell there are nice parser combinators libraries which create very flexible parsers with instance to Applicative.</description></item><item><title>Puzzle 15</title><link>https://anton-k.github.io/dyna-frp/dyna-brick/tutorial/01-puzzle-15/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anton-k.github.io/dyna-frp/dyna-brick/tutorial/01-puzzle-15/</guid><description>In this example we will implement &amp;ldquo;Puzzle 15&amp;rdquo; game in dyna-brick. Here is what end point position look like:
The player tries to arrange numbers on the board. By pressing arrow keys we can substitute some number with an empty box. We win when all numbers are placed in ascending order like it is shown on the picture.
You can find the complete example in the examples of the dyna-brick directory.</description></item><item><title>Quick reference for dyna-brick</title><link>https://anton-k.github.io/dyna-frp/dyna-brick/tutorial/101-reference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anton-k.github.io/dyna-frp/dyna-brick/tutorial/101-reference/</guid><description>All FRP core functions can be used (see the reference for dyna package).
Main types:
Evt a - event streams Dyn a - dynamic values Run a - main app/frp monad BoxId - text based id for the widget Box - widget with id parameter set to BoxId Act - brick app actions (for example Quit) Win - pair of dynamic widgets and event stream of quit-actions Run the application runApp :: Spec -&amp;gt; Run Win -&amp;gt; IO () data Spec = Spec { spec&amp;#39;attrMap :: AttrMap , spec&amp;#39;cursor :: [CursorLocation BoxId] -&amp;gt; Maybe (CursorLocation BoxId) } defSpec :: AttrMap -&amp;gt; Spec emptyAttrMap :: AttrMap data Win = Win { win&amp;#39;widgets :: Dyn [Box] -- ^ window view , win&amp;#39;acts :: Evt Act -- ^ brick app actions } type Box = Widget BoxId newtype BoxId = BoxId { getBoxId :: Text } -- | Actions for Brick rendering engine data Act = Quit -- ^ Quit the app User interaction -- generic terminal events vtyEvents :: Evt Event -- mouse input mouseUp :: Evt MouseUpEvent mouseDown :: Evt MouseDownEvent data MouseUpEvent = MouseUpEvent BoxId (Maybe Button) Location data MouseDownEvent = MouseDownEvent BoxId Button [Modifier] Location -- keyboard input keyEvents :: Evt (Key, [Modifier]) onChar :: Char -&amp;gt; Evt [Modifier] onKey :: Key -&amp;gt; Evt [Modifier] readChars :: Evt Char Drawing Widgets See the modules</description></item><item><title>Quick Reference of dyna-gloss functions</title><link>https://anton-k.github.io/dyna-frp/dyna-gloss/tutorial/101-reference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anton-k.github.io/dyna-frp/dyna-gloss/tutorial/101-reference/</guid><description>All FRP core functions can be used (see the reference for dyna package). Main types
Evt a - event streams Dyn a - dynamic values Run a - main app/frp monad Vec - vectors Point - same as vector Picture - drawing Click - click event Spec - initial config for the application Run the application runApp :: Spec -&amp;gt; Run (Dyn Picture) -&amp;gt; IO () -- init application data Spec = Spec { spec&amp;#39;display :: Display -- ^ display settings , spec&amp;#39;background :: Color -- ^ background color to clear each frame , spec&amp;#39;steps :: Int -- ^ number of steps for simulation } defSpec :: Spec -- | Describes how Gloss should display its output.</description></item><item><title>Quick Reference of dyna-gloss functions</title><link>https://anton-k.github.io/dyna-frp/dyna-processing/tutorial/101-reference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anton-k.github.io/dyna-frp/dyna-processing/tutorial/101-reference/</guid><description>All FRP core functions can be used (see the reference for dyna package). Main types
Evt a - event streams Dyn a - dynamic values Run a - main app/frp monad P2 / P3 - vectors (2D and 3D) Pio a - processing IO-monad Draw - a sequence of drawing instructions (Pio ()) Click - click event Spec - initial config for the application Run the application runApp :: Spec -&amp;gt; Run (Dyn Draw) -&amp;gt; IO () -- init application, setup instructions data Spec = Spec { spec&amp;#39;setup :: Pio () } User interaction -- mouse input mouse :: Dyn P2 mouseRight :: Evt P2 mouseLeft :: Evt P2 mouseMiddle :: Evt P2 mouseWheel :: Evt Float -- mouse pointer velocity mouseV:: Dyn P2 -- mouse pointer acceleration mouseA :: Dyn P2 -- detection of drag action isDrag :: MouseButton -&amp;gt; Dyn Bool drag :: MouseButton -&amp;gt; Dyn P2 dragV :: MouseButton -&amp;gt; Dyn P2 -- generic events data Click = Click (Either Key MouseButton) KeyState Modifiers P2 data KeyState = Up | Down getClicks :: Evt Click -- Time that has passed since previous step of simulation timeInterval :: Dyn Float -- key actions keyUp :: Key -&amp;gt; Evt Modifiers keyDown :: Key -&amp;gt; Evt Modifiers charUp :: Char -&amp;gt; Evt Modifiers charDown :: Char -&amp;gt; Evt Modifiers Drawing pictures and other processing functions See the docs for processing-for-haskell.</description></item><item><title>Quick reference to the core FRP functions</title><link>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/101-reference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/101-reference/</guid><description>There are two core data types:
Evt m a - for event streams Dyn m a - for dynamic processes The Evt is a callback processor. Giving some callback procedure it can run it each time some event happens.
The Dyn is an observation of an event. It&amp;rsquo;s stepwise constant continuous signal of values that starts with some initial value. It produces that value until the next value happen on the event stream then it produces that value until the next value will come.</description></item><item><title>Resources and publications</title><link>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/102-resources/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/102-resources/</guid><description>Library on Hackage:
TODO Publications:
TODO Talks and videos:
TODO Tutorials and guides:
TODO</description></item><item><title>Using dyna to create bindings to imperative libraries</title><link>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/07-make-bindings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anton-k.github.io/dyna-frp/dyna-core/tutorial/07-make-bindings/</guid><description>Here we will see how we can use the library to create FRP-based bindings to various imperative libraries. We will study the common patterns that reappear during the implementation.
For now we have bindings to the libraries brick (TUIs) and gloss (Graphics, gaming). But if you need to use it with your own favorite library and make it shine with FRP you can find this chapter useful.
How to make our own instances for Frp Why do we need our own instances for Frp class?</description></item></channel></rss>