<!doctype html><html lang=en-us>
<head>
<meta property="og:title" content="Callback heaven for FRP">
<meta property="og:description" content="Abstract The Functional reactive programming provides a declarative solution to the task of creation of interactive applications. Often it is contrasted to the imperative approach that relies on callback handlers, event loops and mutation of the state which is quickly can become hard to understand and maintain. In this work we show how with imperative definition we can build DSL that covers all combinators of the FRP approach. We will go to the center of imperative hurricane to build declarative interface that is easy to understand, use and extend.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://anton-k.github.io/dyna-frp/paper/"><meta property="article:section" content>
<meta name=description content="Hardcoded description; the author should update :)">
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta http-equiv=x-ua-compatible content="ie=edge">
<title>Dyna FRP</title>
<link rel=icon type=image/png href=https://anton-k.github.io/dyna-frp/images/favicon.png>
<link href="https://fonts.googleapis.com/css?family=Open+Sans:400,600" rel=stylesheet>
<link rel=stylesheet type=text/css href=https://anton-k.github.io/dyna-frp/css/style.min.e783507bb360b9f98a5ed4a121403993a693ea14a1af9420b35e040e776c22f8.css integrity="sha256-54NQe7NgufmKXtShIUA5k6aT6hShr5Qgs14EDndsIvg=">
<link rel=stylesheet type=text/css href=https://anton-k.github.io/dyna-frp/css/icons.css>
</head>
<body>
<div id=preloader>
<div id=status></div>
</div>
<nav class="navbar is-fresh is-transparent no-shadow" role=navigation aria-label="main navigation">
<div class=container>
<div class=navbar-brand>
<a class=navbar-item href=https://anton-k.github.io/dyna-frp/>
<img src=https://anton-k.github.io/dyna-frp/images/logos/dyna-logo-2.png alt width=112 height=28>
</a>
<a class="navbar-item is-hidden-desktop is-hidden-tablet">
<div id=menu-icon-wrapper class=menu-icon-wrapper style=visibility:visible><svg width="1e3" height="1e3"><path class="path1" d="M3e2 4e2H7e2c2e2.0 2e2 350-1e2 450A4e2 4e2.0 012e2 2e2L8e2 8e2"/><path class="path2" d="M3e2 5e2H7e2"/><path class="path3" d="M7e2 6e2H3e2c-2e2.0-2e2-4e2 1e2-450A4e2 380 0 112e2 8e2L8e2 2e2"/></svg>
<button id=menu-icon-trigger class=menu-icon-trigger></button>
</div>
</a>
<a role=button class=navbar-burger aria-label=menu aria-expanded=false data-target=navbar-menu>
<span aria-hidden=true></span>
<span aria-hidden=true></span>
<span aria-hidden=true></span>
</a>
</div>
<div id=navbar-menu class="navbar-menu is-static">
<div class=navbar-start>
<a class="navbar-item is-hidden-mobile">
<div id=menu-icon-wrapper class=menu-icon-wrapper style=visibility:visible><svg width="1e3" height="1e3"><path class="path1" d="M3e2 4e2H7e2c2e2.0 2e2 350-1e2 450A4e2 4e2.0 012e2 2e2L8e2 8e2"/><path class="path2" d="M3e2 5e2H7e2"/><path class="path3" d="M7e2 6e2H3e2c-2e2.0-2e2-4e2 1e2-450A4e2 380 0 112e2 8e2L8e2 2e2"/></svg>
<button id=menu-icon-trigger class=menu-icon-trigger></button>
</div>
</a>
</div>
<div class=navbar-end>
<a href=https://anton-k.github.io/dyna-frp/ class="navbar-item is-secondary">
Home
</a>
<a href=dyna-core/get-started class="navbar-item is-secondary">
Get started
</a>
<div class="navbar-item has-dropdown is-hoverable">
<a class=navbar-link>
Tutorial
</a>
<div class=navbar-dropdown>
<a href=paper class=navbar-item>
Paper
</a>
<a href=dyna-core/tutorial-toc class=navbar-item>
Core FRP
</a>
<a href=dyna-gloss/tutorial-toc class=navbar-item>
Gloss
</a>
<a href=dyna-brick/tutorial-toc class=navbar-item>
Brick
</a>
<a href=dyna-processing/tutorial-toc class=navbar-item>
Processing
</a>
</div>
</div>
<div class="navbar-item has-dropdown is-hoverable">
<a class=navbar-link>
Reference
</a>
<div class=navbar-dropdown>
<a href=dyna-core/tutorial/101-reference class=navbar-item>
Core FRP
</a>
<a href=dyna-gloss/tutorial/101-reference class=navbar-item>
Gloss
</a>
<a href=dyna-brick/tutorial/101-reference class=navbar-item>
Brick
</a>
<a href=dyna-processing/tutorial/101-reference class=navbar-item>
Processing
</a>
</div>
</div>
<a href=https://github.com/anton-k/dyna-frp class=navbar-item>
<span class="button signup-button rounded secondary-btn raised">
Github
</span>
</a>
</div>
</div>
</div>
</nav>
<nav id=navbar-clone class="navbar is-fresh is-transparent" role=navigation aria-label="main navigation">
<div class=container>
<div class=navbar-brand>
<a class=navbar-item href=https://anton-k.github.io/dyna-frp/>
<img src=https://anton-k.github.io/dyna-frp/images/logos/dyna-logo-2.png alt width=112 height=28>
</a>
<a class="navbar-item is-hidden-desktop is-hidden-tablet">
<div id=menu-icon-wrapper class=menu-icon-wrapper style=visibility:visible><svg width="1e3" height="1e3"><path class="path1" d="M3e2 4e2H7e2c2e2.0 2e2 350-1e2 450A4e2 4e2.0 012e2 2e2L8e2 8e2"/><path class="path2" d="M3e2 5e2H7e2"/><path class="path3" d="M7e2 6e2H3e2c-2e2.0-2e2-4e2 1e2-450A4e2 380 0 112e2 8e2L8e2 2e2"/></svg>
<button id=menu-icon-trigger class=menu-icon-trigger></button>
</div>
</a>
<a role=button class=navbar-burger aria-label=menu aria-expanded=false data-target=cloned-navbar-menu>
<span aria-hidden=true></span>
<span aria-hidden=true></span>
<span aria-hidden=true></span>
</a>
</div>
<div id=cloned-navbar-menu class="navbar-menu is-fixed">
<div class=navbar-start>
<a class="navbar-item is-hidden-mobile">
<div id=cloned-menu-icon-wrapper class=menu-icon-wrapper style=visibility:visible><svg width="1e3" height="1e3"><path class="path1" d="M3e2 4e2H7e2c2e2.0 2e2 350-1e2 450A4e2 4e2.0 012e2 2e2L8e2 8e2"/><path class="path2" d="M3e2 5e2H7e2"/><path class="path3" d="M7e2 6e2H3e2c-2e2.0-2e2-4e2 1e2-450A4e2 380 0 112e2 8e2L8e2 2e2"/></svg>
<button id=cloned-menu-icon-trigger class=menu-icon-trigger></button>
</div>
</a>
</div>
<div class=navbar-end>
<a href=https://anton-k.github.io/dyna-frp/ class="navbar-item is-secondary">
Home
</a>
<a href=dyna-core/get-started class="navbar-item is-secondary">
Get started
</a>
<div class="navbar-item has-dropdown is-hoverable">
<a class=navbar-link>
Tutorial
</a>
<div class=navbar-dropdown>
<a href=paper class=navbar-item>
Paper
</a>
<a href=dyna-core/tutorial-toc class=navbar-item>
Core FRP
</a>
<a href=dyna-gloss/tutorial-toc class=navbar-item>
Gloss
</a>
<a href=dyna-brick/tutorial-toc class=navbar-item>
Brick
</a>
<a href=dyna-processing/tutorial-toc class=navbar-item>
Processing
</a>
</div>
</div>
<div class="navbar-item has-dropdown is-hoverable">
<a class=navbar-link>
Reference
</a>
<div class=navbar-dropdown>
<a href=dyna-core/tutorial/101-reference class=navbar-item>
Core FRP
</a>
<a href=dyna-gloss/tutorial/101-reference class=navbar-item>
Gloss
</a>
<a href=dyna-brick/tutorial/101-reference class=navbar-item>
Brick
</a>
<a href=dyna-processing/tutorial/101-reference class=navbar-item>
Processing
</a>
</div>
</div>
<a href=https://github.com/anton-k/dyna-frp class=navbar-item>
<span class="button signup-button rounded secondary-btn raised">
Github
</span>
</a>
</div>
</div>
</div>
</nav>
<section class="section is-medium">
<div class=container>
<div class=columns>
<div class="column is-centered-tablet-portrait">
<h1 class="title section-title">Callback heaven for FRP</h1>
<h5 class="subtitle is-5 is-muted"></h5>
<div class=divider></div>
</div>
</div>
<div class=content>
<h2 id=abstract>Abstract</h2>
<p>The Functional reactive programming provides a declarative solution
to the task of creation of interactive applications. Often it is contrasted
to the imperative approach that relies on callback handlers, event loops
and mutation of the state which is quickly can become hard to understand and
maintain. In this work we show how with imperative
definition we can build DSL that covers all combinators of the FRP approach.
We will go to the center of imperative hurricane to build declarative
interface that is easy to understand, use and extend. Because of imperative
nature of the definitions it simplifies the creation of bindings to imperative
systems as they speak the same language at the core of the library. Also we show application
of our approach to various domains such as Animation, gaming, UIs, server-side
web programming.</p>
<h2 id=introduction>Introduction</h2>
<p>Working with time is a hard task, because everything starts to depend on context
of execution and order of calls to procedures. One of the main merits of the
functional programming and pure functions is that time does not interfere with
execution of the program. Pure functions produce the same result regardless of when
they are called. Effectful procedures tend to update
mutable state and it is hard to track the updates. As a solution to this problem
FRP treats the whole sequence of events that trigger updates as a single entity
and we can establish relationships between streams of events. And work with them
with convenient interface that looks as if we work with lists.</p>
<p>By treating the event streams as a whole we surpass the problem of event ordering
because we process the infinite stream of events as a whole. But this introduces
its own problems. We need to be careful to not to introduce the space leaks because
some events that should be forgotten are kept in memory. Also it can be hard to
bridge the imperative and declarative approaches because at the end of the day often we
use imperative frameworks as low-level implementation of FRP ideas. Take for example <code>OpenGL</code>
or <code>WxWidgets</code> which are inherently imperative.</p>
<p>In this paper we propose an implementation for FRP system which is imperative
at its core. We use powerful Haskell features such as lazy evaluation and
concurrency to implement FRP combinators on top of imperative definitions.
And we make the imperative world composable and to the end user it seems
that the whole model is declarative and reactive.</p>
<p>Because implementation is imperative at the core it is
easy to implement bindings to such a system and core types a very easy to grasp
and use as example of FRP implementation for education.</p>
<p>Our main contributions:</p>
<ul>
<li>
<p>Minimal and elegant implementation for FRP which is based on imperative approach.</p>
</li>
<li>
<p>Use of concurrency in the FRP system</p>
</li>
<li>
<p>Generic monad at the core of the FRP system</p>
</li>
<li>
<p>Implementation of bindings to several domains:
animation (<code>gloss</code>, <code>processing-for-haskell</code>), UIs (<code>brick</code>), web-servers (<code>scotty</code>)</p>
</li>
</ul>
<p>It was implemented in the library <code>dyna</code>. It is open source and available on Hackage.
The name comes as a short name for &ldquo;dynamic value&rdquo;.</p>
<h2 id=frp-refresher>FRP refresher</h2>
<p>In this section we provide a short overview of functional reactive programming (FRP).
It is a declarative approach to creation of interactive applications.
It studies continuous processes (called Behaviors or Signals) and infinite
streams of events (called Events). Instead of reacting to the user input
and updating the current state we use typical functional programming routines
like map, fold, filter, monoidal interface to establish relationships between
user input and drawings of widgets on the screen.</p>
<p>We have two main types: Behaviours or continuous signals and event streams.</p>
<p>By the meaning the Behavior can be though of continuous function from <code>Time</code> to values:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#8b008b;font-weight:700>type</span> <span style=color:#00688b;font-weight:700>Behavior</span> a <span style=color:#8b008b>=</span> <span style=color:#00688b;font-weight:700>Time</span> <span style=color:#8b008b>-&gt;</span> a
</code></pre></div><p>And event stream is possibly infinite list of events, i.e. values that happen on certain time:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#8b008b;font-weight:700>type</span> <span style=color:#00688b;font-weight:700>Events</span> a <span style=color:#8b008b>=</span> [(<span style=color:#00688b;font-weight:700>Time</span>, a)]
</code></pre></div><p>The magic starts to happen when we bring typical functional programming functions
to the domain of FRP. We use interface for FRP as it was designed in []:</p>
<p>Typical interface for <code>Behaviors</code>:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#8b008b;font-weight:700>instance</span> <span style=color:#00688b;font-weight:700>Functor</span> <span style=color:#00688b;font-weight:700>Behavior</span>
<span style=color:#8b008b;font-weight:700>instance</span> <span style=color:#00688b;font-weight:700>Applicative</span> <span style=color:#00688b;font-weight:700>Behavior</span>
</code></pre></div><p>From the <code>Applicative</code> instance we can derive many useful instances that lift
some instances of the values to the instances of the signals:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#8b008b;font-weight:700>instance</span> <span style=color:#00688b;font-weight:700>Monoid</span> a     <span style=color:#8b008b>=&gt;</span> <span style=color:#00688b;font-weight:700>Monoid</span> (<span style=color:#00688b;font-weight:700>Behabior</span> a)
<span style=color:#8b008b;font-weight:700>instance</span> <span style=color:#00688b;font-weight:700>Num</span> a        <span style=color:#8b008b>=&gt;</span> <span style=color:#00688b;font-weight:700>Num</span> (<span style=color:#00688b;font-weight:700>Behavior</span> a)
<span style=color:#8b008b;font-weight:700>instance</span> <span style=color:#00688b;font-weight:700>Fractional</span> a <span style=color:#8b008b>=&gt;</span> <span style=color:#00688b;font-weight:700>Fractional</span> (<span style=color:#00688b;font-weight:700>Behavior</span> a)
<span style=color:#8b008b;font-weight:700>instance</span> <span style=color:#00688b;font-weight:700>IsString</span> a   <span style=color:#8b008b>=&gt;</span> <span style=color:#00688b;font-weight:700>IsString</span> (<span style=color:#00688b;font-weight:700>Behavrior</span> a)
...
</code></pre></div><p>The interface for event streams also can be expressed with standard type-classes.
We can map over values of events with <code>Functor</code></p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#8b008b;font-weight:700>instance</span> <span style=color:#00688b;font-weight:700>Functor</span> <span style=color:#00688b;font-weight:700>Events</span> <span style=color:#8b008b;font-weight:700>where</span>
</code></pre></div><p>We can join several event streams together with instance of <code>Monoid</code>:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#8b008b;font-weight:700>instance</span> <span style=color:#00688b;font-weight:700>Semigroup</span> (<span style=color:#00688b;font-weight:700>Event</span> a) <span style=color:#8b008b;font-weight:700>where</span>
<span style=color:#8b008b;font-weight:700>instance</span> <span style=color:#00688b;font-weight:700>Monoid</span>    (<span style=color:#00688b;font-weight:700>Event</span> a) <span style=color:#8b008b;font-weight:700>where</span>
</code></pre></div><p>It is important that we can join events regardless of their type. Whereas for Behaviors
we required that parameter of Behavior is also <code>Monoid</code>. Conceptually we can think on join
of events as of merge of two lists of events which are sorted by time of event occurrence.
Also event streams support operations typical for lists:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#008b45>filter</span> <span style=color:#8b008b>::</span> (a <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Bool</span>) <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Events</span> a <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Events</span> a
<span style=color:#008b45>take</span>   <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>Int</span>         <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Events</span> a <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Events</span> a
<span style=color:#008b45>drop</span>   <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>Int</span>         <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Events</span> a <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Events</span> a
<span style=color:#008b45>scan</span>   <span style=color:#8b008b>::</span> (s <span style=color:#8b008b>-&gt;</span> a <span style=color:#8b008b>-&gt;</span> s) <span style=color:#8b008b>-&gt;</span> s <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Events</span> a <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Events</span> s
... etc ... 
</code></pre></div><p>We need some way to interact between events and behaviors:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#008b45>stepper</span> <span style=color:#8b008b>::</span> a <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Events</span> a <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Behavior</span> a
<span style=color:#008b45>apply</span>   <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>Behavior</span> (a <span style=color:#8b008b>-&gt;</span> b) <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Events</span> a <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Events</span> b
</code></pre></div><p>The stepper function creates step-wise behavior that starts with pure
initial value (the first argument) and when event happens on the event stream (second argument)
it starts to produce that value instead until the next event will happen and overwrite the current
value. The <code>apply</code> function applies the dynamic function to the value of event stream when it happens.
The result stream is going to have the same timestamps for events as the input stream
only we are going to map with function which also dynamically changes over time.</p>
<p>We can switch between behaviors and events:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#008b45>switchE</span> <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>Events</span> (<span style=color:#00688b;font-weight:700>Events</span> a) <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Events</span> a
<span style=color:#008b45>switchB</span> <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>Behavior</span> a <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Events</span> (<span style=color:#00688b;font-weight:700>Behavior</span> a) <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Behavior</span> a
</code></pre></div><p>The <code>switchE</code> flattens the event streams. It starts to produce the events
from the first event stream that happens until the next event stream will come and
substitute the previous one and so forth.
In the <code>switchB</code> we flatten the event stream of behaviors to a single behavior.
It works just like <code>stepper</code> only we work not with constant values within the segments
but with behaviors.</p>
<p>On top of those basic functions we can construct many more primitives but this
is the core of FRP system. There are many ways to implement FRP. Mostly they are
divided on classical FRP which implements described interface and Arrowised FRP (AFRP) which
introduce the notion of signal function. It is a function which can be thought of
as iterative transformation of the <code>Behavior</code>.</p>
<p>We propose imperative implementation that is based on the notion of callback procedure.
It turns out that we can create flexible and powerful set of combinators that cover
the whole range of FRP interface with that. But prior to that let us take
a broad view on the problem and study the meaning of the FRP entities from
the philosophical perspective.</p>
<h2 id=imperative-definition>Imperative definition</h2>
<p>What does it mean to be a continuous process or stream of events from the user point of view?
We have just outlined one possible solution described in types:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#8b008b;font-weight:700>type</span> <span style=color:#00688b;font-weight:700>Behavior</span> a <span style=color:#8b008b>=</span> <span style=color:#00688b;font-weight:700>Time</span> <span style=color:#8b008b>-&gt;</span> a
<span style=color:#8b008b;font-weight:700>type</span> <span style=color:#00688b;font-weight:700>Events</span> a <span style=color:#8b008b>=</span> [(<span style=color:#00688b;font-weight:700>Time</span>, a)]
</code></pre></div><p>It introduces the relation of behaviors and streams to a time.
We assume that there is a time line in which we observe the events or values
of behaviors.</p>
<p>What if we can eliminate the time completely? If instead of thinking
about what event is we can think about why do we need it in the first place.
This is kind of categorical view on the problem when we study not what objects
are but how they are related to other objects.</p>
<p>For our implementation we assume that user needs event stream to react
on events and it does not matter when event will happen as long as we
know that some procedure is going to be called in that moment.</p>
<p>We can picture it:</p>
<figure><img src=https://anton-k.github.io/dyna-frp/images/run-evt.svg alt="Run event" width=90%>
</figure>
<p>We define the event stream of <code>a</code> in terms of function <code>runEvt</code> which
takes in a callback procedure <code>a -> m ()</code> and does something
useful with it whenever event happens. The <code>m</code> is some monad
that is akin to <code>IO</code>. But when does it going to happen
is completely hidden from the user.</p>
<p>Also we can think of behaviors in terms of how they can be used in real world.
Take for example the current temperature of the weather.
We can try to forecast it but the only reliable thing we can do is to measure
it in the current time. For us behavior is kind of reference to the mutable
process that evolves in background and the only thing we can do is to query
the current value of the process.</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#008b45>readDynRef</span> <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>DynRef</span> m a <span style=color:#8b008b>-&gt;</span> m a
</code></pre></div><p>Also as the dynamic value is a background process we need some way to
gracefully shut it down:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#008b45>cancelDyn</span> <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>DynRef</span> m a <span style=color:#8b008b>-&gt;</span> m <span style=color:#658b00>()</span>
</code></pre></div><p>We are going to call behaviors of this kind dynamic values (<code>Dyn</code> for short in the code)
If we have some definition of the process for dynamic value we can run it in background
and get the reference to it:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#008b45>runDyn</span> <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>Dyn</span> m a <span style=color:#8b008b>-&gt;</span> m (<span style=color:#00688b;font-weight:700>DynRef</span> m a)
</code></pre></div><p>So we have two imperative definitions:</p>
<p>The event stream <code>Evt</code> is a callback consumer function:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#8b008b;font-weight:700>newtype</span> <span style=color:#00688b;font-weight:700>Evt</span> m a <span style=color:#8b008b>=</span> <span style=color:#00688b;font-weight:700>Evt</span> { runEvt <span style=color:#8b008b>::</span> (a <span style=color:#8b008b>-&gt;</span> m <span style=color:#658b00>()</span>) <span style=color:#8b008b>-&gt;</span> m <span style=color:#658b00>()</span> }
</code></pre></div><p>And the dynamic value is some background process to which we have access
over reading its current value. We can read it only at the current moment:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#008b45>runDyn</span>    <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>Dyn</span>    m a <span style=color:#8b008b>-&gt;</span> m (<span style=color:#00688b;font-weight:700>DynRef</span> m a)
<span style=color:#008b45>readDyn</span>   <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>DynRef</span> m a <span style=color:#8b008b>-&gt;</span> m a
<span style=color:#008b45>cancelDyn</span> <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>DynRef</span> m a <span style=color:#8b008b>-&gt;</span> m <span style=color:#658b00>()</span>
</code></pre></div><p>We need to refine the notion of <code>Dyn</code>. What type of process is it?
We define it in terms of event streams. It is observation of current value
of some underlying event stream.</p>
<p>We are going to have some initial value, event stream and getter function:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#8b008b;font-weight:700>data</span> <span style=color:#00688b;font-weight:700>Dyn</span> m a <span style=color:#8b008b>=</span> forall s . <span style=color:#00688b;font-weight:700>Dyn</span> 
  { dyn&#39;init    <span style=color:#8b008b>::</span> s
  , dyn&#39;evt     <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>Evt</span> m s
  , dyn&#39;get     <span style=color:#8b008b>::</span> s <span style=color:#8b008b>-&gt;</span> m a
  }
</code></pre></div><p>So at the beginning of the process we observe the initial value <code>dyn'init</code>
and produce (<code>dyn'get dyn'init</code>) until the next event will happen. We store it
in the mutable value (it can be <code>IORef</code> for example). When it will happen we will
update the mutable value and start to produce another value.
We use trick with <code>forall</code> to hide away the internal representation of the state
from the user. The implementation in the library also contains a method:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#008b45>dyn&#39;release</span> <span style=color:#8b008b>::</span> m <span style=color:#658b00>()</span>
</code></pre></div><p>It holds procedure to release resources allocated for the work of event stream <code>dyn'evt</code>
but we omit it for the sake of simplicity.</p>
<p>At the core of our system is a notion of event stream as callback consumer.
The dynamic value is an observation of some event stream. It turns out that
with this imperative definition we can implement all functions from the classical FRP
interface.</p>
<p>Let us start with interfaces for event streams. As we go we will encounter
constraints for the monad <code>m</code>.</p>
<h2 id=event-stream-interface>Event stream interface</h2>
<p>Event streams are the core of our system as dynamic values are defined in terms
of event streams. The vent streams are callback consumer functions. The
combinators for them are going to take the input callback functions and
append some useful functionality on top of them.</p>
<h3 id=event-stream-constructors>Event stream constructors</h3>
<p>The simplest possible event stream is <code>never</code>. It never happens
and the implementation just ignores the callback and returns:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#008b45>never</span> <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>Monad</span> m <span style=color:#8b008b>=&gt;</span> <span style=color:#00688b;font-weight:700>Evt</span> m a
<span style=color:#008b45>never</span> <span style=color:#8b008b>=</span> <span style=color:#00688b;font-weight:700>Evt</span> $ <span style=color:#008b45>\</span><span style=color:#8b008b;font-weight:700>_</span> <span style=color:#8b008b>-&gt;</span> pure <span style=color:#658b00>()</span>
</code></pre></div><p>The next basic primitive is <code>once</code>. It is some event that happens only once
right at the start:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#008b45>once</span> <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>Monad</span> m <span style=color:#8b008b>=&gt;</span> m a <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Evt</span> m a
<span style=color:#008b45>once</span> act <span style=color:#8b008b>=</span> <span style=color:#00688b;font-weight:700>Evt</span> $ <span style=color:#008b45>\</span>go <span style=color:#8b008b>-&gt;</span> go =&lt;&lt; act
</code></pre></div><p>It just invokes the callback once and returns. For example with <code>once</code>
we can create an event stream that queries user for input:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#008b45>getLineE</span> <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>Evt</span> <span style=color:#00688b;font-weight:700>IO</span> a
<span style=color:#008b45>getLineE</span> <span style=color:#8b008b>=</span> once getLine
</code></pre></div><p>To print the events we can define useful functions that calls <code>print</code> as a callback:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#008b45>printE</span> <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>Show</span> a <span style=color:#8b008b>=&gt;</span> <span style=color:#00688b;font-weight:700>Evt</span> <span style=color:#00688b;font-weight:700>IO</span> a <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>IO</span> <span style=color:#658b00>()</span>
<span style=color:#008b45>printE</span> evt <span style=color:#8b008b>=</span> runEvt evt print
</code></pre></div><h3 id=sequential-composition>Sequential composition</h3>
<p>With our definition of events we can introduce sequential composition.
As we define our event stream as monadic procedure it makes it simple
to define the function that implements one monadic action after another one.
It is when we have two event streams that produce the events of the same type
we can run the first one with our callback and when it finishes we can the second one:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#008b45>seqE</span> <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>Monad</span> m <span style=color:#8b008b>=&gt;</span> <span style=color:#00688b;font-weight:700>Evt</span> m a <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Evt</span> m a <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Evt</span> m a
<span style=color:#008b45>seqE</span> a b <span style=color:#8b008b>=</span> <span style=color:#00688b;font-weight:700>Evt</span> $ <span style=color:#008b45>\</span>go <span style=color:#8b008b>-&gt;</span> <span style=color:#8b008b;font-weight:700>do</span>
  runEvt a go
  runEvt b go
</code></pre></div><p>Note how the nature of monad being a sequence of procedures
produces very simple definition for sequencing of event streams.
With this function we can ask user for input several times:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#008b45>getLineE</span> `seqE` getLineE 
</code></pre></div><p>Also using the same idea it is easy to provide the <code>foreverE</code>
function that calls event stream in infinite loop. We just lift
the standard function for monads <code>forever</code> to the event streams:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#008b45>foreverE</span> <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>Monad</span> m <span style=color:#8b008b>=&gt;</span> <span style=color:#00688b;font-weight:700>Evt</span> m a <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Evt</span> m a
<span style=color:#008b45>foreverE</span> e <span style=color:#8b008b>=</span> <span style=color:#00688b;font-weight:700>Evt</span> $ <span style=color:#008b45>\</span>go <span style=color:#8b008b>-&gt;</span> forever (runEvt e go)
</code></pre></div><p>Note how sequential composition does not rely on the notion of time.
It is defined in terms of one goes after another one finishes
but introduction of the time is still avoided.</p>
<h3 id=parallel-composition>Parallel composition</h3>
<p>With concurrent libraries we can define the parallel composition of
event streams. Two event streams happen concurrently if they run at
the same time and we pass the same callback to them and whenever
event happens on any of the streams it triggers the callback procedure:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#008b45>parE</span> <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>MonadBaseControl</span> m <span style=color:#8b008b>=&gt;</span> <span style=color:#00688b;font-weight:700>Evt</span> m a <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Evt</span> m a <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Evt</span> m a
<span style=color:#008b45>parE</span> a b <span style=color:#8b008b>=</span> <span style=color:#00688b;font-weight:700>Evt</span> $ <span style=color:#008b45>\</span>go <span style=color:#8b008b>-&gt;</span> concurrently_ (runEvt a go) (runEvt b go)
</code></pre></div><p>We use the function <code>concurrently_</code> from the library <code>async-lifted</code> to
run both event streams at the same time.The class <code>MonadBaseControl</code>
let us run processes concurrently not only on top of <code>IO</code> monad
but on any monad that is instance of it. It gives us great flexibility
over the choice of the underlying monad.</p>
<h3 id=frp-monad-class>Frp-monad class</h3>
<p>For the sake of brevity we define the <code>Frp</code>-class for a monad
that is suitable for using with <code>Evt</code>, <code>Dyn</code> and FRP interface:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#8b008b;font-weight:700>class</span> <span style=color:#00688b;font-weight:700>MonadBaseControl</span> m <span style=color:#8b008b>=&gt;</span> <span style=color:#00688b;font-weight:700>Frp</span> m <span style=color:#8b008b;font-weight:700>where</span>
</code></pre></div><h3 id=monoid-instance>Monoid instance</h3>
<p>With <code>never</code> we can define Monoid either with sequential composition
or with parallel composition. In FRP libraries the Monoid instance
usually means parallel composition:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#8b008b;font-weight:700>instance</span> <span style=color:#00688b;font-weight:700>Frp</span> m <span style=color:#8b008b>=&gt;</span> <span style=color:#00688b;font-weight:700>Semigroup</span> (<span style=color:#00688b;font-weight:700>Evt</span> m a) <span style=color:#8b008b;font-weight:700>where</span>
  (&lt;&gt;) <span style=color:#8b008b>=</span> parE

<span style=color:#8b008b;font-weight:700>instance</span> <span style=color:#00688b;font-weight:700>Frp</span> m <span style=color:#8b008b>=&gt;</span> <span style=color:#00688b;font-weight:700>Monoid</span> (<span style=color:#00688b;font-weight:700>Evt</span> m a) <span style=color:#8b008b;font-weight:700>where</span>
  mempty <span style=color:#8b008b>=</span> never
</code></pre></div><h3 id=functor-instance>Functor instance</h3>
<p>It is also useful to be able to transform event streams.
For example if we want to read only integer input from the user:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#008b45>readInt</span> <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>String</span> <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Maybe</span> <span style=color:#00688b;font-weight:700>Int</span>

<span style=color:#008b45>readIntE</span> <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>Evt</span> <span style=color:#00688b;font-weight:700>IO</span> (<span style=color:#00688b;font-weight:700>Maybe</span> <span style=color:#00688b;font-weight:700>Int</span>)
<span style=color:#008b45>readIntE</span> <span style=color:#8b008b>=</span> foreverE (fmap readInt getLineE)
</code></pre></div><p>We assume the existence of the function <code>readInt</code> that reads only integers
from the input.</p>
<p>In the definition of the <code>Functor</code> we just apply the function to transform
the input prior to callback invocation:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#8b008b;font-weight:700>instance</span> <span style=color:#00688b;font-weight:700>Frp</span> m <span style=color:#8b008b>=&gt;</span> <span style=color:#00688b;font-weight:700>Functor</span> (<span style=color:#00688b;font-weight:700>Evt</span> m) <span style=color:#8b008b;font-weight:700>where</span>
  fmap f e <span style=color:#8b008b>=</span> <span style=color:#00688b;font-weight:700>Evt</span> $ <span style=color:#008b45>\</span>go <span style=color:#8b008b>-&gt;</span> runEvt e (go . f)
</code></pre></div><h3 id=list-like-functions>List-like functions</h3>
<p>What makes the definition of applications in FRP-style great is
that many combinators look like functions for ordinary list.
We work with event streams as if they are lists although under the hood
thy are functions with side effects. Let us look at couple of definitions.</p>
<h4 id=filtering>Filtering</h4>
<p>Let&rsquo;s define some list-like functions. Let us take for example <code>filterE</code>:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#008b45>filterE</span> <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>Frp</span> m <span style=color:#8b008b>=&gt;</span> (a <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Bool</span>) <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Evt</span> m a <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Evt</span> m a
<span style=color:#008b45>filterE</span> cond e <span style=color:#8b008b>=</span> <span style=color:#00688b;font-weight:700>Evt</span> $ <span style=color:#008b45>\</span>go <span style=color:#8b008b>-&gt;</span> 
  runEvt e $ <span style=color:#008b45>\</span>x <span style=color:#8b008b>-&gt;</span> when (cond x) (go x)
</code></pre></div><p>Once again we don&rsquo;t need the notion of time to filter the events.
We just ride on top of the monad function <code>when</code> that can skip
execution of monadic actions based on condition.</p>
<h4 id=scanning>Scanning</h4>
<p>The scan function accumulates the state with some function
whenever event happens on the stream:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#008b45>scan</span> <span style=color:#8b008b>::</span> (a <span style=color:#8b008b>-&gt;</span> st <span style=color:#8b008b>-&gt;</span> st) <span style=color:#8b008b>-&gt;</span> st <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Evt</span> m a <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Evt</span> m st
</code></pre></div><p>This function is a bit tricky. As to implement it we are going to need the mutable
variables. We need to store the current state and update it on the event.
For simplicity we take the <code>IORef</code> to store the state but the implementation also
provides <code>TVar</code> to store values more safely in the presence of
possible concurrent updates.</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#008b45>scan</span> f init e <span style=color:#8b008b>=</span> <span style=color:#00688b;font-weight:700>Evt</span> $ <span style=color:#008b45>\</span>go <span style=color:#8b008b>-&gt;</span> <span style=color:#8b008b;font-weight:700>do</span>
  ref <span style=color:#8b008b>&lt;-</span> liftIO (newIORef evt s)
  runEvt evt $ <span style=color:#008b45>\</span>x <span style=color:#8b008b>-&gt;</span> <span style=color:#8b008b;font-weight:700>do</span>
    s <span style=color:#8b008b>&lt;-</span> f x &lt;$&gt; liftIO (readIORef ref)
    go s
    liftIO $ writeIORef ref s
</code></pre></div><p>We allocate a mutable reference under the hood and update it on every trigger
of the callback function. And this is all hidden from the user behind
the declarative interface of function <code>scan</code>.</p>
<p>In this manner we can implement many list functions. But we stop for now
and resume with interface for dynamics.</p>
<h3 id=rock-paper-scissors-game>Rock Paper Scissors game</h3>
<p>We would like to provide the feel of usage of FRP library that
we have just defined. As example we list implementation
of the game of Rock Paper Scissors. In the game two players show random
hand gestures to each other. There are three gestures: Rock, Paper and Scissors.
And Paper wins over Rock, Rock wins over Scissors and Scissors win over Paper.
If gestures are the same it is a draw.</p>
<p>It takes just a 7 lines of FRP-code to implement the logic of the game
and uses only event stream functions.
Here is the complete code for the FRP-part of the Rock-Paper-Scissors game.
The pipe operator <code>|></code> is just flipped <code>$</code> application operator:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#8b008b;font-weight:700>data</span> <span style=color:#00688b;font-weight:700>Move</span> <span style=color:#8b008b>=</span> <span style=color:#00688b;font-weight:700>Rock</span> | <span style=color:#00688b;font-weight:700>Paper</span> | <span style=color:#00688b;font-weight:700>Scissors</span>
<span style=color:#8b008b;font-weight:700>data</span> <span style=color:#00688b;font-weight:700>Score</span> <span style=color:#8b008b>=</span> <span style=color:#00688b;font-weight:700>Score</span> {...}
  
<span style=color:#008b45>toScore</span>    <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>Move</span> <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Move</span> <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Score</span>    <span style=color:#228b22>-- convert moves to score for a single round</span>
<span style=color:#008b45>printScore</span>                             <span style=color:#228b22>-- pretty prints the score</span>
           <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>RoundId</span> <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Score</span> <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>String</span>
<span style=color:#008b45>total</span>      <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>Int</span>                      <span style=color:#228b22>-- number of rounds</span>

<span style=color:#008b45>game</span> <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>Evt</span> <span style=color:#00688b;font-weight:700>IO</span> <span style=color:#00688b;font-weight:700>String</span>
<span style=color:#008b45>game</span> <span style=color:#8b008b>=</span>
  once getLine |&gt; foreverE |&gt;           <span style=color:#228b22>-- read user input</span>
  mapMay (readMaybe @<span style=color:#00688b;font-weight:700>Move</span>) |&gt;           <span style=color:#228b22>-- take only valid moves</span>
  takeE total |&gt;                        <span style=color:#228b22>-- take only so many moves</span>
  withOneOf [<span style=color:#00688b;font-weight:700>Rock</span>, <span style=color:#00688b;font-weight:700>Paper</span>, <span style=color:#00688b;font-weight:700>Scissors</span>] |&gt;  <span style=color:#228b22>-- add random AI move as first element of the tuple</span>
  foldMapE (uncurry $ flip toScore) |&gt;  <span style=color:#228b22>-- get the score and accumulate scores</span>
  withCount |&gt;                          <span style=color:#228b22>-- append the round number</span>
  fmap (printScore total)               <span style=color:#228b22>-- print the current score</span>
</code></pre></div><p>The steps are explained in the comments. We just create the infinite
stream of user input and filter only valid moves. After that we take
only so many moves as it&rsquo;s needed by the game. We append to the user&rsquo;s
move the random move of the game-engine and <code>foldMap</code> it with conversion
to the score. The function <code>withCount</code> appends the current count of
the events so far. As the last stage we pretty print the scores on
each round.</p>
<h2 id=interface-for-dynamic-values>Interface for dynamic values</h2>
<p>We have defined the interface for the core type - event streams.
Let us dive into dynamic values. We can recall that dynamic values
are just event streams in disguise. We turn the streams to processes
by observation of the last event value that has happened on the stream.</p>
<p>Let us reminder the definition:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#8b008b;font-weight:700>data</span> <span style=color:#00688b;font-weight:700>Dyn</span> m a <span style=color:#8b008b>=</span> forall s . <span style=color:#00688b;font-weight:700>Dyn</span> 
  { dyn&#39;init    <span style=color:#8b008b>::</span> s           <span style=color:#228b22>-- ^ initial state</span>
  , dyn&#39;evt     <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>Evt</span> m s     <span style=color:#228b22>-- ^ event stream that updates the state</span>
  , dyn&#39;get     <span style=color:#8b008b>::</span> s <span style=color:#8b008b>-&gt;</span> m a    <span style=color:#228b22>-- ^ getter function for the state</span>
  }
</code></pre></div><h3 id=basic-building-blocks>Basic building blocks</h3>
<p>We can create a dynamic from an effectful value:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#008b45>constDyn</span> <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>Monad</span> m <span style=color:#8b008b>=&gt;</span> m a <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Dyn</span> m a
<span style=color:#008b45>constDyn</span> a <span style=color:#8b008b>=</span> <span style=color:#00688b;font-weight:700>Dyn</span> 
  { dyn&#39;init <span style=color:#8b008b>=</span> <span style=color:#658b00>()</span>
  , dyn&#39;evt  <span style=color:#8b008b>=</span> never
  , dyn&#39;get  <span style=color:#8b008b>=</span> const a
  }
</code></pre></div><p>It uses the event that never happens to update the value.
And the getter function <code>dyn'get</code> just uses the input to produce the value.</p>
<p>Also the definition of dynamic value lends itself to the
construction of dynamic values from event streams:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#008b45>hold</span> <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>Monad</span> m <span style=color:#8b008b>=&gt;</span> a <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Evt</span> m a <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Dyn</span> m a
<span style=color:#008b45>hold</span> init evt <span style=color:#8b008b>=</span> <span style=color:#00688b;font-weight:700>Dyn</span>
  { dyn&#39;init <span style=color:#8b008b>=</span> init
  , dyn&#39;evt  <span style=color:#8b008b>=</span> evt
  , dyn&#39;get  <span style=color:#8b008b>=</span> pure
  }
</code></pre></div><p>For dynamics we need to define only couple of interfaces: <code>Functor</code> and <code>Applicative</code>.
Let&rsquo;s start with the <code>Functor</code>.</p>
<h3 id=functor-instance-1>Functor instance</h3>
<p>The <code>Functor</code> case is simple we just need to change our point of view
on the returning value with getter function:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#8b008b;font-weight:700>instance</span> <span style=color:#00688b;font-weight:700>Fynctor</span> m <span style=color:#8b008b>=&gt;</span> <span style=color:#00688b;font-weight:700>Functor</span> (<span style=color:#00688b;font-weight:700>Dyn</span> m) <span style=color:#8b008b;font-weight:700>where</span>
  fmap f (<span style=color:#00688b;font-weight:700>Dyn</span> init evt get) <span style=color:#8b008b>=</span> <span style=color:#00688b;font-weight:700>Dyn</span> init evt (fmap f . get)    
</code></pre></div><h3 id=applicative-functor-instance>Applicative functor instance</h3>
<p>Let&rsquo;s define first an easy case for <code>pure</code>:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#8b008b;font-weight:700>instance</span> <span style=color:#00688b;font-weight:700>Frp</span> m <span style=color:#8b008b>=&gt;</span> <span style=color:#00688b;font-weight:700>Applicative</span> (<span style=color:#00688b;font-weight:700>Dyn</span> m) <span style=color:#8b008b;font-weight:700>where</span>
  pure a <span style=color:#8b008b>=</span> constDyn (pure a)
</code></pre></div><p>The bind of applicative functor is a bit tricky to get right because
it implies the construction of single event stream for internal
state update out of two argument streams. The main idea is to use monoid
instance to run two event streams concurrently
and use a pair of states as a result state. And whenever any of the components
updates we also update the internal pair of sates:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell>  (&lt;*&gt;) <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>Dyn</span> m (a <span style=color:#8b008b>-&gt;</span> b) <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Dyn</span> m a <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Dyn</span> m b
  (&lt;*&gt;) (<span style=color:#00688b;font-weight:700>Dyn</span> initF evtF getF) (<span style=color:#00688b;font-weight:700>Dyn</span> initA evtA getA) <span style=color:#8b008b>=</span> <span style=color:#00688b;font-weight:700>Dyn</span> init evt get
    <span style=color:#8b008b;font-weight:700>where</span>
      init <span style=color:#8b008b>=</span> (initF, initA)

      evt <span style=color:#8b008b>=</span> <span style=color:#00688b;font-weight:700>Evt</span> $ <span style=color:#008b45>\</span>go <span style=color:#8b008b>-&gt;</span> runEvt (fmap <span style=color:#00688b;font-weight:700>Left</span> evtF &lt;&gt; fmap <span style=color:#00688b;font-weight:700>Right</span> evtA) $ <span style=color:#008b45>\</span>(f, a) <span style=color:#8b008b>-&gt;</span> <span style=color:#8b008b;font-weight:700>case</span> x <span style=color:#8b008b;font-weight:700>of</span>
              <span style=color:#00688b;font-weight:700>Left</span>  f&#39; <span style=color:#8b008b>-&gt;</span> go (f&#39;, a)
              <span style=color:#00688b;font-weight:700>Right</span> a&#39; <span style=color:#8b008b>-&gt;</span> go (f, a&#39;)

      get (f, a) <span style=color:#8b008b>=</span> pure (f a)
</code></pre></div><p>We have defined the main functions for dynamic values!</p>
<h2 id=interaction-between-events-and-dynamics>Interaction between events and dynamics</h2>
<p>Let&rsquo;s define application of the dynamic function to the event stream.
To do that we start to listen for dynamic values and each time
the callback is triggered on input stream we just read the
dynamic function by reference and apply it to callback argument:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#008b45>apply</span> <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>Frp</span> m <span style=color:#8b008b>=&gt;</span> <span style=color:#00688b;font-weight:700>Dyn</span> m (a <span style=color:#8b008b>-&gt;</span> b) <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Evt</span> m a <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Evt</span> m b
<span style=color:#008b45>apply</span> dyn evt <span style=color:#8b008b>=</span> <span style=color:#00688b;font-weight:700>Evt</span> $ <span style=color:#008b45>\</span>go <span style=color:#8b008b>-&gt;</span> <span style=color:#8b008b;font-weight:700>do</span>
  ref <span style=color:#8b008b>&lt;-</span> runDyn dyn
  runEvt evt (<span style=color:#008b45>\</span>b <span style=color:#8b008b>-&gt;</span> <span style=color:#8b008b;font-weight:700>do</span>
    go . ($ b) =&lt;&lt; readDyn ref)
    `finally` cancelDyn ref
</code></pre></div><p>We need to be careful to stop the background process
when we do not need it anymore. For that we use the <code>finally</code>
primitive which is going to be called even if the exception
will be thrown in the thread of the event stream.
The implementation for flattening functions <code>swithE</code> and <code>switchB</code>
is tricky story and we list it in the appendix for the interested reader.</p>
<h2 id=where-the-time-is>Where the time is</h2>
<p>It is interesting that we still do not need to use the notion of time.
How should we interact with it? We can introduce it with
primitive which calls a procedure on the given time interval.
Assume that we have predefined function <code>preiodic</code>:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#008b45>preiodic</span> <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>Monad</span> m <span style=color:#8b008b>=&gt;</span> <span style=color:#00688b;font-weight:700>Time</span> <span style=color:#8b008b>-&gt;</span> m <span style=color:#658b00>()</span> <span style=color:#8b008b>-&gt;</span> m <span style=color:#658b00>()</span>
</code></pre></div><p>It calls procedure every so many seconds. It is easy to implement it
with <code>treadDelay</code> function which can wait in the thread.</p>
<p>With it we can define an event stream that calls callback periodically:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#008b45>pulse</span> <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>Frp</span> m <span style=color:#8b008b>=&gt;</span> <span style=color:#00688b;font-weight:700>Time</span> <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Evt</span> m <span style=color:#658b00>()</span>
<span style=color:#008b45>pulse</span> t <span style=color:#8b008b>=</span> <span style=color:#00688b;font-weight:700>Evt</span> $ <span style=color:#008b45>\</span>go <span style=color:#8b008b>-&gt;</span> periodic t (go <span style=color:#658b00>()</span>)
</code></pre></div><p>This is enough to sample the timeline with the granularity that we would
like to have. With this event stream we can start to work with time
but the library of FRP-combinators itself does not need it for implementation.
This separation of interface from the time allows us to keep decisions of<br>
the granularity and preciseness of time orthogonal to the whole system.</p>
<h2 id=more-fruits-from-concurrent-haskell>More fruits from Concurrent Haskell</h2>
<p>As we saw the application of a function <code>concurrently_</code> from the <code>asyn-lifted</code> library.
We can use other functions to give concurrent flavor to the execution
of event streams. For example we can also use <code>race</code>:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#008b45>raceE</span> <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>Frp</span> m <span style=color:#8b008b>=&gt;</span> <span style=color:#00688b;font-weight:700>Evt</span> m a <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Evt</span> m a <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Evt</span> m a
<span style=color:#008b45>raceE</span> a b <span style=color:#8b008b>=</span> <span style=color:#00688b;font-weight:700>Evt</span> $ <span style=color:#008b45>\</span>go <span style=color:#8b008b>-&gt;</span> race_ (runEvt a go) (runEvt b go)
</code></pre></div><p>It will run both of the events concurrently and finish both
of the event streams when one of them will finish. It can be useful
to timeout the execution of event streams.</p>
<p>Also we can create a combinator that handles all callbacks concurrently
by running each callback in a separate thread:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#008b45>forkE</span> <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>Evt</span> m a <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Evt</span> m a
<span style=color:#008b45>forkE</span> e <span style=color:#8b008b>=</span> <span style=color:#00688b;font-weight:700>Evt</span> $ <span style=color:#008b45>\</span>go <span style=color:#8b008b>-&gt;</span> runEvt e (fork . go)
</code></pre></div><h2 id=recursion>Recursion</h2>
<p>It is often useful to use recursive event streams. For example
we can have a button widget which has dynamic attribute text on the button
and we would like to show how many times
the button was pressed with it. The code can look like this:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#008b45>clicks</span> <span style=color:#8b008b>&lt;-</span> button (fmap show $ hold <span style=color:#b452cd>0</span> $ count clicks)
</code></pre></div><p>Where <code>count</code> counts how many times event has occurred on the stream.
So we need clicks as output and as input of the function.
We can not do it directly with our framework because event streams
are functions under the hood and we can not tie the knot over generic
function definition.</p>
<p>To solve this problem we introduce a combinator:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#008b45>fixE</span> <span style=color:#8b008b>::</span> (<span style=color:#00688b;font-weight:700>Evt</span> m a <span style=color:#8b008b>-&gt;</span> m (<span style=color:#00688b;font-weight:700>Evt</span> m a)) <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Evt</span> m a
</code></pre></div><p>It takes in a function which transforms the event streams and produces
a single event stream. It feeds the output stream of the function back to itself.
With this combinator we can implement the <code>button</code>:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#008b45>fixE</span> $ <span style=color:#008b45>\</span>clicks <span style=color:#8b008b>-&gt;</span> button (fmap show $ hold <span style=color:#b452cd>0</span> $ count clicks)
</code></pre></div><p>To implement this function we need to introduce another useful concept.
Event streams which are based on concurrent channels.
We can initialise a channel (for example <code>TChan</code> from the library <code>stm</code>).
And in the event loop we can listen for messages and each time the message
occurs we are going to trigger the callback.</p>
<p>The definition for <code>TChan</code>:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#008b45>tchanEvt</span> <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>Frp</span> m <span style=color:#8b008b>=&gt;</span> <span style=color:#00688b;font-weight:700>TChan</span> a <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Evt</span> m a
<span style=color:#008b45>tchanEvt</span> chan <span style=color:#8b008b>=</span> <span style=color:#00688b;font-weight:700>Evt</span> $ <span style=color:#008b45>\</span>go <span style=color:#8b008b>-&gt;</span> <span style=color:#8b008b;font-weight:700>do</span>
  ref <span style=color:#8b008b>&lt;-</span> liftIO $ atomically $ dupTChan chan
  loop ref go
  <span style=color:#8b008b;font-weight:700>where</span>
    loop ref go <span style=color:#8b008b>=</span> <span style=color:#8b008b;font-weight:700>do</span>
      a <span style=color:#8b008b>&lt;-</span> liftIO $ atomically $ readTChan ref
      go a
      loop chan go
</code></pre></div><p>With it we can implement the <code>fixE</code>. To redirect the events form output
to input we are going to create a channel and we will write all events
from the output to it and we will create an event stream from that channel
and apply it to the recursive function:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#008b45>fixE</span> <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>Frp</span> m <span style=color:#8b008b>=&gt;</span> (<span style=color:#00688b;font-weight:700>Evt</span> m a <span style=color:#8b008b>-&gt;</span> m (<span style=color:#00688b;font-weight:700>Evt</span> m a)) <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Evt</span> m a
<span style=color:#008b45>fixE</span> f <span style=color:#8b008b>=</span> <span style=color:#00688b;font-weight:700>Evt</span> $ <span style=color:#008b45>\</span>go <span style=color:#8b008b>-&gt;</span> <span style=color:#8b008b;font-weight:700>do</span>
  chan <span style=color:#8b008b>&lt;-</span> liftIO newTChanIO
  <span style=color:#8b008b;font-weight:700>let</span> evt <span style=color:#8b008b>=</span> tchanEvt chan
  evt&#39; <span style=color:#8b008b>&lt;-</span> f evt
  runEvt evt&#39; $ <span style=color:#008b45>\</span>x <span style=color:#8b008b>-&gt;</span> <span style=color:#8b008b;font-weight:700>do</span>
    liftIO $ atomically $ writeTChan chan x
    go x
</code></pre></div><h2 id=sharing-of-event-streams>Sharing of event streams</h2>
<p>We have defined a nice DSL of FRP combinators on top of our imperative definition
of event streams. But it&rsquo;s good to be aware of its limitations.
Each event stream is an effectful function under the hood and we
combine them to produce new functions that can produce side effects too.
This means that we accumulate the description of execution of some callback
rather than the execution itself.</p>
<p>It can lead to confusion with the usage of Haskell sharing of the variables
with <code>let</code> or <code>where</code> expressions. For example we have a function:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#008b45>oneOf</span> <span style=color:#8b008b>::</span> [a] <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Evt</span> b <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>Evt</span> a
</code></pre></div><p>Which for every event in the second argument stream produces
event that contains one random element from the list.
If we use it in the code:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#8b008b;font-weight:700>let</span> a <span style=color:#8b008b>=</span> oneOf [<span style=color:#00688b;font-weight:700>True</span>, <span style=color:#00688b;font-weight:700>False</span>] evt
    b <span style=color:#8b008b>=</span> a
<span style=color:#8b008b;font-weight:700>in</span>  f a b
</code></pre></div><p>It&rsquo;s useful to understand that <code>a</code> and <code>b</code> will produce two different
instances of the random process. More than that even in the expression:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#8b008b;font-weight:700>let</span> a <span style=color:#8b008b>=</span> oneOf [<span style=color:#00688b;font-weight:700>True</span>, <span style=color:#00688b;font-weight:700>False</span>] evt
<span style=color:#8b008b;font-weight:700>in</span>  f a a
</code></pre></div><p>In the function <code>f</code> on execution of callback procedure two arguments
of <code>f</code> will produce different random sequences although they point to the same
variable <code>a</code>. But it is important to understand that <code>a</code> contains a description
of the callback consumer and not the evaluation of it.</p>
<p>Often we want to share the values between streams and to solve this problem
we introduce a special function:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#008b45>newEvt</span> <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>Evt</span> m a <span style=color:#8b008b>-&gt;</span> m (<span style=color:#00688b;font-weight:700>Evt</span> m a)
</code></pre></div><p>It creates a concurrent channel and starts to execute its argument event stream
with callback that writes values of events to the concurrent channel.
As a result we return the event stream that listens to that channel.</p>
<p>This way if we copy this description we copy the listener to the same channel and
both of the copies would receive the same events:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell>  <span style=color:#8b008b;font-weight:700>do</span>
    a <span style=color:#8b008b>&lt;-</span> newEvt (oneOf [<span style=color:#00688b;font-weight:700>True</span>, <span style=color:#00688b;font-weight:700>False</span>] evt)
    pure (f a a)
</code></pre></div><p>In this expression the function <code>f</code> will receive the same
events on execution from both <code>a</code>s. In the library we have the
same function to share dynamic values.</p>
<p>Some FRP libraries solve this problem by usage of <code>unsafePerformIO</code>
to update the network of mutable references to the vent streams and keep sharing consistent
with the sharing of the Haskell values. We decided not to go down this road
and keep it explicit for the user.</p>
<h2 id=creation-of-bindings-to-imperative-libraries>Creation of bindings to imperative libraries</h2>
<p>One of the strength of this approach to FRP implementation comes from
how easy it is to create bindings to imperative libraries.
Because the underlying types use imperative approach too.
The general technique is to use <code>ReaderT</code> monad with
environment that contains concurrent channels or mutable variables
that are written from imperative evaluation loop of the imperative library.</p>
<p>Let&rsquo;s outline the structure of bindings to the <code>gloss</code> animation library.
It offers great declarative interface
for creation of animations but the main rendering loop functions
like an imperative state-machine.
Here is a simplified version of the function (we omit initialisation parameters):</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#008b45>playIO</span> 
 <span style=color:#8b008b>::</span> world                               <span style=color:#228b22>-- initial value of the state</span>
 <span style=color:#8b008b>-&gt;</span> (world <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>IO</span> <span style=color:#00688b;font-weight:700>Picture</span>)               <span style=color:#228b22>-- render the state on the screen </span>
 <span style=color:#8b008b>-&gt;</span> (<span style=color:#00688b;font-weight:700>Event</span> <span style=color:#8b008b>-&gt;</span> world <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>IO</span> world)        <span style=color:#228b22>-- update the state on events</span>
 <span style=color:#8b008b>-&gt;</span> (<span style=color:#00688b;font-weight:700>Float</span> <span style=color:#8b008b>-&gt;</span> world <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>IO</span> world)        <span style=color:#228b22>-- update the state on interation step</span>
 <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>IO</span> <span style=color:#658b00>()</span>
</code></pre></div><p>To use it with our FRP-library we create environment type which will
hold the events:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#8b008b;font-weight:700>newtype</span> <span style=color:#00688b;font-weight:700>Env</span> <span style=color:#8b008b>=</span> <span style=color:#00688b;font-weight:700>Env</span> { unEnv <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>TChan</span> <span style=color:#00688b;font-weight:700>Event</span> }
</code></pre></div><p>And our main FRP-monad would be reader-transformer with access to that channel:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#8b008b;font-weight:700>type</span> <span style=color:#00688b;font-weight:700>Run</span> a <span style=color:#8b008b>=</span> <span style=color:#00688b;font-weight:700>ReaderT</span> <span style=color:#00688b;font-weight:700>Env</span> <span style=color:#00688b;font-weight:700>IO</span> a
</code></pre></div><p>Our main rendering function will take a dynamic value of pictures as input:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#008b45>runGloss</span> <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>Run</span> (<span style=color:#00688b;font-weight:700>Dyn</span> <span style=color:#00688b;font-weight:700>Run</span> <span style=color:#00688b;font-weight:700>Picture</span>) <span style=color:#8b008b>-&gt;</span> <span style=color:#00688b;font-weight:700>IO</span> <span style=color:#658b00>()</span>
</code></pre></div><p>The <code>gloss</code>-level state of our application will be the reference to the dynamic value.
In the rendering on the screen we will just query the current value:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#008b45>runGloss</span> pictureDyn <span style=color:#8b008b>=</span> <span style=color:#8b008b;font-weight:700>do</span>
  env <span style=color:#8b008b>&lt;-</span> initEnv
  ref <span style=color:#8b008b>&lt;-</span> runReaderT (runDyn pictureDyn) env
  <span style=color:#228b22>-- world == DynRef Run Picture</span>
  <span style=color:#8b008b;font-weight:700>let</span> draw ref <span style=color:#8b008b>=</span> runReaderT (readDyn ref) env
</code></pre></div><p>In the rendering function we will initialise the environment and inside
update of the events we will just dump all the events to the channel that is stored in the
environment:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell>  <span style=color:#8b008b;font-weight:700>let</span> update event ref <span style=color:#8b008b>=</span> <span style=color:#8b008b;font-weight:700>do</span>
    atomically $ writeTChan (unEnv env) event
    pure ref

  <span style=color:#8b008b;font-weight:700>let</span> frameUpdate <span style=color:#8b008b;font-weight:700>_</span> ref <span style=color:#8b008b>=</span> pure ref
</code></pre></div><p>With those functions we are ready to run the imperative gloss rendering function:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell>  playIO draw update frameUpdate
</code></pre></div><p>That&rsquo;s all we need to do. To provide the user with nice event stream of events
we access the environment by the reader monad and wrap it to the event:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#008b45>getEvents</span> <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>Evt</span> <span style=color:#00688b;font-weight:700>Run</span> <span style=color:#00688b;font-weight:700>Event</span>
<span style=color:#008b45>getEvents</span> <span style=color:#8b008b>=</span> <span style=color:#00688b;font-weight:700>Evt</span> $ <span style=color:#008b45>\</span>go <span style=color:#8b008b>-&gt;</span> <span style=color:#8b008b;font-weight:700>do</span>
  (<span style=color:#00688b;font-weight:700>Env</span> eventChan) <span style=color:#8b008b>&lt;-</span> ask
  runEvt (tchanEvt eventChan) go
</code></pre></div><p>To make user experience nicer in the real library we also created wrappers
that settle down the generic monad parameter for event streams and dynamic values:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#8b008b;font-weight:700>newtype</span> <span style=color:#00688b;font-weight:700>Evt</span> a <span style=color:#8b008b>=</span> <span style=color:#00688b;font-weight:700>Evt</span> (<span style=color:#00688b;font-weight:700>Dyna</span>.<span style=color:#00688b;font-weight:700>Evt</span> <span style=color:#00688b;font-weight:700>Run</span> a)
<span style=color:#8b008b;font-weight:700>newtype</span> <span style=color:#00688b;font-weight:700>Dyn</span> a <span style=color:#8b008b>=</span> <span style=color:#00688b;font-weight:700>Dyn</span> (<span style=color:#00688b;font-weight:700>Dyna</span>.<span style=color:#00688b;font-weight:700>Dyn</span> <span style=color:#00688b;font-weight:700>Run</span> a)
</code></pre></div><p>So the signature of the previous example looks more easy to understand:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#008b45>getEvents</span> <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>Evt</span> <span style=color:#00688b;font-weight:700>Event</span>
</code></pre></div><h2 id=applications>Applications</h2>
<p>The same technique of keeping communication with imperative event loop
over concurrent channels works for many other libraries. We have created
bindings to animation libraries <code>gloss</code> and <code>processing-for-haskell</code>,
also bindings to TUI library <code>brick</code> and for server side web-library <code>scotty</code>.</p>
<h3 id=animations>Animations</h3>
<p>Creation of animations for the first impulse to creation of FRP approach.
And indeed ti fits nicely to that domain. Let&rsquo;s show the hello world program
for <code>gloss</code> bindings to see how those ideas can be used in practice.</p>
<p>In the program we have a solid circle that is drawn in the mouse pointer:</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#008b45>main</span> <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>IO</span> <span style=color:#658b00>()</span>
<span style=color:#008b45>main</span> <span style=color:#8b008b>=</span> runApp defSpec $ pure pic

<span style=color:#008b45>pic</span> <span style=color:#8b008b>::</span> <span style=color:#00688b;font-weight:700>Dyn</span> <span style=color:#00688b;font-weight:700>Picture</span>
<span style=color:#008b45>pic</span> <span style=color:#8b008b>=</span> (<span style=color:#008b45>\</span>pos <span style=color:#8b008b>-&gt;</span> translate pos $ color green $ circleSolid <span style=color:#b452cd>50</span>) &lt;$&gt; mouse
</code></pre></div><p>Note how we use the <code>Functor</code> instance to transform the dynamic value of
current <code>mouse</code> pointer position to the pictures of circles.
And it produces the picture as dynamic value.</p>
<h3 id=tuis>TUIs</h3>
<p>We can create terminal user interfaces with <code>brick</code> library and
to find out how FRP will work in that setting we have created a binding to it
which is called <code>dyna-brick</code>. We have implemented a 15 puzzle game
and 2048 games to test how it works. And it was great experience.
The game becomes a scan over user moves which for both games
are just the arrow moves or <code>Esc</code> or <code>q</code> to quit and <code>r</code> to restart the game.</p>
<p>To give a taste of implementation we can show the most interesting FRP parts
of it. Here is a 15 puzzle</p>
<div class=highlight><pre tabindex=0 style=background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#008b45>show</span> me what you ve got

</code></pre></div><h3 id=web-servers>Web servers</h3>
<h2 id=comparison-to-other-frp-libraries>Comparison to other FRP libraries</h2>
<p>There are many FRP libraries in the Haskell ecosystem.
There is a league of libraries that implement classic FRP like <code>reactive-banana</code>, <code>reflex</code> or
<code>frp-now</code> and also there is big family of libraries that implement Arrow-style FRP,
most notorious are <code>Yampa</code> and <code>Dunai</code>. As we see it the place of the <code>dyna</code> library among
those is for educational reasons, because model is very simple to grasp and also
it&rsquo;s imperative nature makes it a good fit to create bindings to imperative libraries.
Other nice properties is due to update in place we don&rsquo;t have holding to the past problem and
space leaks that are connected with that another interesting property is that <code>dyna</code>
library is based on concurrency from the ground up.
It would be interesting to see how the concurrency strain of it will evolve
and if it become more prominent and affect the design choices for the applications
written in it.</p>
<h2 id=further-work>Further work</h2>
<p>We plan to implement more bindings. It would be interesting to create bindings
to <code>wxWidgets</code> library to create desktop applications. As we already tested out the TUIs
with brick. It was easy to implement and start with it is interesting to see how this
approach will develop with Desktop applications which often asks for recursive definitions
of the widgets.</p>
<p>Another interesting direction is to try out the concept for the dynamic DOM applications.
The callback-style implementation requires from the host language to have mutable variables
and being able to create concurrent processes. We are interested to implement
the library in <code>purescript</code> as it offers very lean and great to read <code>javascript</code> output
comparing to <code>ghcjs</code> compiler. We would like to try out our ideas with <code>purescript</code>
and see how far we can get with that as <code>Javascript</code> offers concurrent workers
and there are works that make this feature available to <code>purescript</code>.</p>
<h2 id=conclusion>Conclusion</h2>
<p>In this paper we have discussed a novel and elegant approach to FRP implementation.
In this approach instead of hiding away the imperative logic from the user we use
it as a cornerstone of our library and expose internals. We have shown how to implement
the combinators for classical FRP and that it can be done in elegant and generic
manner with the help of powerful concurrency model of the Haskell language.
Being able to use generic concurrency routines from the libraries <code>lifted-base</code>
and <code>async-lifted</code> is a cornerstone of our implementation and what makes it
easy to implement and extend.</p>
<p>We hope that this will inspire the FRP users to experiment with this approach
for teaching and for real applications!</p>
</div>
</div>
</section>
<footer class="footer footer-dark">
<div class=container>
<div class=columns>
<div class=column>
<div class=footer-logo>
<a href=https://anton-k.github.io/dyna-frp/>
<img src=https://anton-k.github.io/dyna-frp/images/logos/dyna-logo-white-2.png>
</a>
</div>
</div>
<div class=column>
<div class=footer-column>
<div class=footer-header>
<h3>Docs</h3>
</div>
<ul class=link-list>
<li>
<a href=https://anton-k.github.io/dyna-frp/dyna-core/get-started>
Get started
</a>
</li>
<li>
<a href=https://anton-k.github.io/dyna-frp/dyna-core/tutorial-toc>
Tutorial
</a>
</li>
<li>
<a href=https://anton-k.github.io/dyna-frp/paper>
Paper
</a>
</li>
<li>
<a href=https://hackage.haskell.org/package/dyna>
Hackage
</a>
</li>
</ul>
</div>
</div>
<div class=column>
<div class=footer-column>
<div class=footer-header>
<h3>Bindings</h3>
</div>
<ul class=link-list>
<li>
<a href=https://anton-k.github.io/dyna-frp/dyna-brick/tutorial-toc>
Brick
</a>
</li>
<li>
<a href=https://anton-k.github.io/dyna-frp/dyna-gloss/tutorial-toc>
Gloss
</a>
</li>
<li>
<a href=https://anton-k.github.io/dyna-frp/dyna-processing/tutorial-toc>
Processing
</a>
</li>
</ul>
</div>
</div>
<div class=column>
<div class=footer-column>
<div class=footer-header>
<h3>Hackage</h3>
</div>
<ul class=link-list>
<li>
<a href=https://hackage.haskell.org/package/dyna>
Core FRP
</a>
</li>
<li>
<a href=https://hackage.haskell.org/package/dyna-brick>
Brick
</a>
</li>
<li>
<a href=https://hackage.haskell.org/package/dyna-gloss>
Gloss
</a>
</li>
<li>
<a href=https://hackage.haskell.org/package/dyna-processing>
Processing
</a>
</li>
</ul>
</div>
</div>
<div class=column>
<div class=footer-column>
<div class=footer-header>
<h3>Follow Us</h3>
<nav class="level is-mobile">
<div class=level-left>
<a class=level-item href=https://github.com/anton-k/dyna-frp/>
<span class=icon><i class="fa fa-github"></i></span>
</a>
</div>
</nav>
</div>
</div>
</div>
</div>
</div>
</footer>
<div id=backtotop><a href=#></a></div>
<div class=sidebar>
<div class=sidebar-header>
<img src=https://anton-k.github.io/dyna-frp/images/logos/fresh-square.svg>
<a class=sidebar-close href=javascript:void(0);>
<i data-feather=x></i>
</a>
</div>
<div class=inner>
<ul class=sidebar-menu>
<li class=have-children>
<a href=#>
<span class="fa fa-user"></span>
Core
</a>
<ul>
<li>
<a href=dyna-core/tutorial/01-intro>
Introduction
</a>
</li>
<li>
<a href=dyna-core/tutorial/02-event-streams>
Event streams
</a>
</li>
<li>
<a href=dyna-core/tutorial/03-event-game-example>
Console game example
</a>
</li>
<li>
<a href=dyna-core/tutorial/04-dynamics>
Dynamic values
</a>
</li>
<li>
<a href=dyna-core/tutorial/05-backbone-monad>
Main FRP monad
</a>
</li>
<li>
<a href=dyna-core/tutorial/06-control-flow>
Control flow. Sharing and Recursion
</a>
</li>
<li>
<a href=dyna-core/tutorial/07-make-bindings>
Bindings to imperative libraries
</a>
</li>
<li>
<a href=dyna-core/tutorial/08-parser>
Parsers of event streams
</a>
</li>
<li>
<a href=dyna-core/tutorial/09-conclusion>
Conclusion
</a>
</li>
<li>
<a href=dyna-core/tutorial/101-reference>
Quick reference
</a>
</li>
</ul>
</li>
<li class=have-children>
<a href=#>
<span class="fa fa-envelope"></span>
Brick
</a>
<ul>
<li>
<a href=dyna-brick/tutorial/00-intro>
Introduction
</a>
</li>
<li>
<a href=dyna-brick/tutorial/01-puzzle-15>
Example: Puzzle 15
</a>
</li>
<li>
<a href=dyna-brick/tutorial/101-reference>
Quick reference
</a>
</li>
</ul>
</li>
<li class=have-children>
<a href=#>
<span class="fa fa-image"></span>
Gloss
</a>
<ul>
<li>
<a href=dyna-gloss/tutorial/00-intro>
Introduction
</a>
</li>
<li>
<a href=dyna-gloss/tutorial/01-example>
Example
</a>
</li>
<li>
<a href=dyna-gloss/tutorial/101-reference>
Quick reference
</a>
</li>
</ul>
</li>
<li class=have-children>
<a href=#>
<span class="fa fa-image"></span>
Processing
</a>
<ul>
<li>
<a href=dyna-processing/tutorial/00-intro>
Introduction
</a>
</li>
<li>
<a href=dyna-processing/tutorial/01-example>
Example
</a>
</li>
<li>
<a href=dyna-processing/tutorial/101-reference>
Quick reference
</a>
</li>
</ul>
</li>
<li class=have-children>
<a href=#>
<span class="fa fa-cog"></span>
Resources
</a>
<ul>
<li>
<a href=https://anton-k.github.io/dyna-frp/>
Publications
</a>
</li>
<li>
<a href=https://anton-k.github.io/dyna-frp/>
Video
</a>
</li>
<li>
<a href=https://anton-k.github.io/dyna-frp/>
Examples
</a>
</li>
</ul>
</li>
</ul>
</div>
</div>
<script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js></script>
<script src=https://unpkg.com/feather-icons></script>
<script src=https://anton-k.github.io/dyna-frp/js/fresh.js></script>
<script src=https://anton-k.github.io/dyna-frp/js/jquery.panelslider.min.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.8.3/modernizr.min.js></script>
</body>
</html>